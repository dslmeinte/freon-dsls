// Generated by the ProjectIt Language Generator.
import { JsonEveryConcept } from "../../language/gen";
import {
    JsonBoolean,
    JsonObject,
    JsonArray,
    JsonNull,
    JsonUndefined,
    JsonNumber,
    JsonString,
    JsonKeyValuePair,
    JsonValue,
    JsonFile,
    JsonDirectory,
    JsonFiles
} from "../../language/gen";
import { JsonWorker } from "./JsonWorker";
import { PiLogger } from "@projectit/core";

const LOGGER = new PiLogger("JsonWalker");

/**
 * Class JsonWalker implements the extended visitor pattern of instances of language Json.
 * This class implements the traversal of the model tree, classes that implement JsonWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class JsonWalker {
    myWorkers: JsonWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: JsonEveryConcept, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof JsonBoolean) {
                return this.walkJsonBoolean(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonObject) {
                return this.walkJsonObject(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonArray) {
                return this.walkJsonArray(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonNull) {
                return this.walkJsonNull(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonUndefined) {
                return this.walkJsonUndefined(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonNumber) {
                return this.walkJsonNumber(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonString) {
                return this.walkJsonString(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonKeyValuePair) {
                return this.walkJsonKeyValuePair(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonValue) {
                return this.walkJsonValue(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonFile) {
                return this.walkJsonFile(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonDirectory) {
                return this.walkJsonDirectory(modelelement, includeChildren);
            }
            if (modelelement instanceof JsonFiles) {
                return this.walkJsonFiles(modelelement, includeChildren);
            }
        } else {
            LOGGER.error(this, "No worker found.");
        }
    }

    private walkJsonBoolean(modelelement: JsonBoolean, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonBoolean(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonBoolean(modelelement);
            }
        }
    }

    private walkJsonObject(modelelement: JsonObject, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonObject(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.pairs.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonObject(modelelement);
            }
        }
    }

    private walkJsonArray(modelelement: JsonArray, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonArray(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.members.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonArray(modelelement);
            }
        }
    }

    private walkJsonNull(modelelement: JsonNull, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonNull(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonNull(modelelement);
            }
        }
    }

    private walkJsonUndefined(modelelement: JsonUndefined, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonUndefined(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonUndefined(modelelement);
            }
        }
    }

    private walkJsonNumber(modelelement: JsonNumber, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonNumber(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonNumber(modelelement);
            }
        }
    }

    private walkJsonString(modelelement: JsonString, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonString(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonString(modelelement);
            }
        }
    }

    private walkJsonKeyValuePair(modelelement: JsonKeyValuePair, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonKeyValuePair(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.value)) {
            this.walk(modelelement.value, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonKeyValuePair(modelelement);
            }
        }
    }

    private walkJsonValue(modelelement: JsonValue, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonValue(modelelement);
            }
        }
    }

    private walkJsonFile(modelelement: JsonFile, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonFile(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.contents)) {
            this.walk(modelelement.contents, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonFile(modelelement);
            }
        }
    }

    private walkJsonDirectory(modelelement: JsonDirectory, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonDirectory(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.files.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonDirectory(modelelement);
            }
        }
    }

    private walkJsonFiles(modelelement: JsonFiles, includeChildren?: (elem: JsonEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeJsonFiles(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.dirs.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterJsonFiles(modelelement);
            }
        }
    }
}
