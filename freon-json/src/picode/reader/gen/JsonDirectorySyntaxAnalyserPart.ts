// Generated by the ProjectIt Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    JsonDirectory,
    JsonFile,
    JsonString,
    JsonNumber,
    JsonUndefined,
    JsonNull,
    JsonArray,
    JsonObject,
    JsonKeyValuePair,
    JsonBoolean,
    JsonValue
} from "../../language/gen";
import { JsonSyntaxAnalyser } from "./JsonSyntaxAnalyser";
import { PiElementReference } from "@projectit/core";

export class JsonDirectorySyntaxAnalyserPart {
    mainAnalyser: JsonSyntaxAnalyser;

    constructor(mainAnalyser: JsonSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonDirectory = 'directory' identifier
     *	 JsonFile* ;
     * @param branch
     * @private
     */
    public transformJsonDirectory(branch: SPPTBranch): JsonDirectory {
        // console.log('transformJsonDirectory called: ' + branch.name);
        let __name: string;
        let __files: JsonFile[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[2].name !== "JsonFile") {
            __files = this.mainAnalyser.transformSharedPackedParseTreeList<JsonFile>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __files = [];
            for (const child of children) {
                __files.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return JsonDirectory.create({
            name: __name,
            files: __files,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonFile = 'file' identifier
     *	 JsonValue ;
     * @param branch
     * @private
     */
    public transformJsonFile(branch: SPPTBranch): JsonFile {
        // console.log('transformJsonFile called: ' + branch.name);
        let __name: string;
        let __contents: JsonValue;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __contents = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry

        return JsonFile.create({
            name: __name,
            contents: __contents,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonString = '\"' stringLiteral '\"' ;
     * @param branch
     * @private
     */
    public transformJsonString(branch: SPPTBranch): JsonString {
        // console.log('transformJsonString called: ' + branch.name);
        let __value: string;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry

        return JsonString.create({
            value: __value,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonNumber = stringLiteral ;
     * @param branch
     * @private
     */
    public transformJsonNumber(branch: SPPTBranch): JsonNumber {
        // console.log('transformJsonNumber called: ' + branch.name);
        let __value: string;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return JsonNumber.create({
            value: __value,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonUndefined = 'undefined' ;
     * @param branch
     * @private
     */
    public transformJsonUndefined(branch: SPPTBranch): JsonUndefined {
        // console.log('transformJsonUndefined called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return JsonUndefined.create({
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonNull = 'null' ;
     * @param branch
     * @private
     */
    public transformJsonNull(branch: SPPTBranch): JsonNull {
        // console.log('transformJsonNull called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return JsonNull.create({
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonArray = '[' [ JsonValue / ',' ]* ']' ;
     * @param branch
     * @private
     */
    public transformJsonArray(branch: SPPTBranch): JsonArray {
        // console.log('transformJsonArray called: ' + branch.name);
        let __members: JsonValue[];
        const children = this.mainAnalyser.getChildren(branch);
        __members = this.mainAnalyser.transformSharedPackedParseTreeList<JsonValue>(children[1], ","); // RHSPartListWithSeparator

        return JsonArray.create({
            members: __members,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonObject = '\{'
     *	 [ JsonKeyValuePair / ',' ]*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformJsonObject(branch: SPPTBranch): JsonObject {
        // console.log('transformJsonObject called: ' + branch.name);
        let __pairs: JsonKeyValuePair[];
        const children = this.mainAnalyser.getChildren(branch);
        __pairs = this.mainAnalyser.transformSharedPackedParseTreeList<JsonKeyValuePair>(children[1], ","); // RHSPartListWithSeparator

        return JsonObject.create({
            pairs: __pairs,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonKeyValuePair = '\"' stringLiteral '\":' JsonValue ;
     * @param branch
     * @private
     */
    public transformJsonKeyValuePair(branch: SPPTBranch): JsonKeyValuePair {
        // console.log('transformJsonKeyValuePair called: ' + branch.name);
        let __key: string;
        let __value: JsonValue;
        const children = this.mainAnalyser.getChildren(branch);
        __key = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry

        return JsonKeyValuePair.create({
            key: __key,
            value: __value,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonBoolean = booleanLiteral ;
     * @param branch
     * @private
     */
    public transformJsonBoolean(branch: SPPTBranch): JsonBoolean {
        // console.log('transformJsonBoolean called: ' + branch.name);
        let __value: boolean;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry

        return JsonBoolean.create({
            value: __value,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * JsonValue = JsonUndefined
     *    | JsonNull
     *    | JsonArray
     *    | JsonObject
     *    | JsonString
     *    | JsonNumber
     *    | JsonBoolean  ;
     * @param branch
     * @private
     */
    public transformJsonValue(branch: SPPTBranch): JsonValue {
        // console.log('transformJsonValue called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }
}
