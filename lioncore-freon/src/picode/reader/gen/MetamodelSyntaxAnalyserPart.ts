// Generated by the ProjectIt Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { Metamodel, MetamodelElement } from "../../language/gen";
import { LIonCoreSyntaxAnalyser } from "./LIonCoreSyntaxAnalyser";
import { PiElementReference } from "@projectit/core";

export class MetamodelSyntaxAnalyserPart {
    mainAnalyser: LIonCoreSyntaxAnalyser;

    constructor(mainAnalyser: LIonCoreSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Metamodel = 'metamodel' stringLiteral
     *	 MetamodelElement* ;
     * @param branch
     * @private
     */
    public transformMetamodel(branch: SPPTBranch): Metamodel {
        // console.log('transformMetamodel called: ' + branch.name);
        let __qualifiedName: string;
        let __elements: MetamodelElement[];
        const children = this.mainAnalyser.getChildren(branch);
        __qualifiedName = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[2].name !== "MetamodelElement") {
            __elements = this.mainAnalyser.transformSharedPackedParseTreeList<MetamodelElement>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __elements = [];
            for (const child of children) {
                __elements.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Metamodel.create({
            qualifiedName: __qualifiedName,
            elements: __elements,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * MetamodelElement = 'ERROR' ; // there are no concepts that implement this interface or extend this abstract concept
     * @param branch
     * @private
     */
    public transformMetamodelElement(branch: SPPTBranch): MetamodelElement {
        // console.log('transformMetamodelElement called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }
}
